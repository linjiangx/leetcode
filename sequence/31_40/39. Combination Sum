#
class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        results = []
        candidates.sort()
        self.helper(candidates, target, [], results)
        return results
        
    def helper(self, candidates, target, result, results):
        if target == 0:
            results.append(result)
            return
        
        for i in range(len(candidates)):
            if target < candidates[i]:
                return
            self.helper(candidates[i:], target - candidates[i], result + [candidates[i]], results)

#recurse
class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        candidates.sort()
        solution = []
        def comb(res, candidates, target, count):
            if sum(res) > target:
                return
            elif sum(res) == target:
                solution.append(res)
                return
            else:
                for i in range(len(candidates)):
                    if i >= count:
                        temp = [candidates[i]]
                        comb(res+temp, candidates, target, i)
       
        comb([], candidates, target, 0)
        return solution
